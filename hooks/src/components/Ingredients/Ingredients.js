import React, {useState, useEffect, useCallback} from 'react';

import IngredientForm from './IngredientForm';
import IngredientList from './IngredientList';
import Search from './Search';



const Ingredients = () => {
  const [userIngredients, setUserIngredients] = useState([]);

  // useEffect run just after first and every render cycle
  // useEffect(() => {
  //   fetch('https://practice-react-ingredients.firebaseio.com/ingredients.json').then(
  //     response => response.json()
  //   ).then(responseData => {
  //     const loadedIngredients = [];
  //     for (const key in responseData) {
  //       loadedIngredients.push({
  //         id: key,
  //         title: responseData[key].title,
  //         amount: responseData[key].amount
  //       });
  //     }
  //     setUserIngredients(loadedIngredients);
  //   })
  // }, []);
  // used like this (with [] as second argument)
  // useEffect acts like componentDidmount: runs only once

  // no more needed cause search component fetch the data

  const filteredIngredinetsHandler = useCallback(filteredIngredients => {
    setUserIngredients(filteredIngredients);
  }, []);
  // make this function not re-created if the dependency changes
  // so this prevent re-render child component useeffect (with dependency of this func)

  const addIngredientHandler = ingredient => {
    fetch('https://practice-react-ingredients.firebaseio.com/ingredients.json', {
      method: 'POST',
      body: JSON.stringify(ingredient),
      headers: { 'Content-Type': 'application/json' }
    }).then(response => {
      return response.json();
    }).then(responseData => {
      setUserIngredients(prevIngredients => [
        ...prevIngredients, 
        { id: responseData.name, ...ingredient }
      ]);
        // responseData.name = id no. automatically generated by firebase
    });
    // we want to update to latest ingredients
    // prevIngredients = most recent ingredients
    // ...prevIngredients = all previous ingredients, 
    // add new ingredients list{}
  };

  const removeIngredientHandler = targetId => {
    setUserIngredients(prevIngredients => prevIngredients.filter( el => el.id !== targetId));
  };
  // const removeIngredientHandler = targetId => {
  //   setUserIngredients(prevIngredients => {
  //       return prevIngredients.filter( el => {
  //         return el.id !== targetId ;
  //       })
  //     }
  //     );
  // };

  return (
    <div className="App">
      <IngredientForm onAddIngredient = {addIngredientHandler} />

      <section>
        <Search onloadIngredients={filteredIngredinetsHandler} />
        <IngredientList ingredients={userIngredients} onRemoveItem={removeIngredientHandler}/>
      </section>
    </div>
  );
}

export default Ingredients;
